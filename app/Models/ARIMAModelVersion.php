<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Builder;
use Carbon\Carbon;

class ARIMAModelVersion extends Model
{
    use HasFactory;

    /**
     * The table associated with the model.
     *
     * @var string
     */
    protected $table = 'arima_model_versions';

    /**
     * The attributes that are mass assignable.
     *
     * @var array<int, string>
     */
    protected $fillable = [
        'version_date',
        'training_date',
        'last_data_date',
        'order_p',
        'order_d',
        'order_q',
        'aic',
        'bic',
        'mse',
        'file_path',
        'notes',
    ];

    /**
     * The attributes that should be cast.
     *
     * @var array<string, string>
     */
    protected $casts = [
        'version_date' => 'date',
        'training_date' => 'date',
        'last_data_date' => 'date',
        'order_p' => 'integer',
        'order_d' => 'integer',
        'order_q' => 'integer',
        'aic' => 'decimal:4',
        'bic' => 'decimal:4',
        'mse' => 'decimal:4',
    ];

    /**
     * Get the forecasts generated by this model version.
     */
    public function forecasts()
    {
        return $this->hasMany(TBForecast::class, 'model_version', 'version_date');
    }

    /**
     * Get the filename of the model file.
     *
     * @return string
     */
    public function getFilenameAttribute()
    {
        return basename($this->file_path);
    }

    /**
     * Get the ARIMA order as an array.
     *
     * @return array
     */
    public function getOrderAttribute()
    {
        return [$this->order_p, $this->order_d, $this->order_q];
    }

    /**
     * Get the ARIMA order as a string (e.g., "ARIMA(1,1,1)").
     *
     * @return string
     */
    public function getOrderStringAttribute()
    {
        return "ARIMA({$this->order_p},{$this->order_d},{$this->order_q})";
    }

    /**
     * Get the latest model version.
     *
     * @param Builder $query
     * @return Builder
     */
    public function scopeLatest(Builder $query)
    {
        return $query->orderBy('version_date', 'desc');
    }

    /**
     * Get models trained within a specific date range.
     *
     * @param Builder $query
     * @param string|Carbon $startDate
     * @param string|Carbon $endDate
     * @return Builder
     */
    public function scopeTrainedBetween(Builder $query, $startDate, $endDate)
    {
        return $query->whereBetween('training_date', [$startDate, $endDate]);
    }

    /**
     * Load the actual Python ARIMA model.
     *
     * @return mixed|null The loaded model or null if file doesn't exist
     */
    public function loadModel()
    {
        $path = storage_path('app/models/' . $this->file_path);

        if (file_exists($path)) {
            try {
                // This requires the Python joblib library to be available via the php-python extension
                // or through a system call to load the model
                // For demonstration, we'll just return the path that would be used
                return "Model would be loaded from: {$path}";

                // In a real implementation with python integration:
                // return \PythonBridge::call('joblib.load', $path);
            } catch (\Exception $e) {
                \Log::error("Failed to load ARIMA model: {$e->getMessage()}");
                return null;
            }
        }

        return null;
    }

    /**
     * Calculate the age of the model in days.
     *
     * @return int
     */
    public function getAgeInDaysAttribute()
    {
        return $this->version_date->diffInDays(Carbon::now());
    }

    /**
     * Determine if this is the current active model.
     *
     * @return bool
     */
    public function getIsCurrentAttribute()
    {
        return $this->id === self::latest()->first()->id;
    }

    /**
     * Get the validation rules for creating/updating an ARIMA model version.
     *
     * @return array
     */
    public static function validationRules()
    {
        return [
            'version_date' => 'required|date',
            'training_date' => 'required|date',
            'last_data_date' => 'required|date',
            'order_p' => 'required|integer|min:0|max:10',
            'order_d' => 'required|integer|min:0|max:2',
            'order_q' => 'required|integer|min:0|max:10',
            'aic' => 'nullable|numeric',
            'bic' => 'nullable|numeric',
            'mse' => 'nullable|numeric',
            'file_path' => 'required|string|max:255',
            'notes' => 'nullable|string',
        ];
    }
}
